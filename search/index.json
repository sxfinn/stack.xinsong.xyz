[{"content":"","date":"2022-12-07T14:16:43+08:00","permalink":"https://stack.xinsong.xyz/p/test/","title":"Test"},{"content":"C++关键字 C++关键字全集(参考 C++ Primer ):\nasm auto bad _cast bad _typeid bool break case catch char class const const _cast continue default delete do double dynamic _cast else enum except explicit extern false finally float for friend goto if inline int long mutable namespace new operator private protected public register reinterpret _cast return short signed sizeof static static _cast struct switch template this throw true try type _info typedef typeid typename union unsigned using virtual void volatile wchar_t while 命名空间 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的，std：c++标准库的命名空间。\n在C语言中我们如果使用了同一个标识符定义了不同的函数或者是变量，会导致它们之间产生冲突，而C++为了解决这个问题，引入了命名空间的概念，不同命名空间的成员占有不同的内存空间，即使名称相同，但相互之间并不会受到影响。因此在C++中，库函数也是被定义在命名空间中的。\n例如：C语言的头文件包含通常是 #include\u0026lt;xxx.h\u0026gt;，包含后我们便可以直接使用库函数，而在C++中我们的头文件通常是： #include\u0026lt;xxx\u0026gt;，并且无法直接使用库函数，必须要指定命名空间std才能使用。\n不过C++是兼容C几乎所以语法的，因此我们可以在C++中穿插C的代码，不过有一些混用是很容易出错的，要小心并且正确的使用。\n命名空间定义 定义命名空间需要使用namespace关键字，后面跟上要定义的命名空间的名字，将命名空间成员定义在后面的{}内即可，类似于结构体和类的定义方式。\n命名空间内可以定义变量，函数，类型，使用命名空间的类型定义出的变量不属于命名空间。\n一般的命名空间定义方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 namespace sx { int a; void swap(int\u0026amp; a, int\u0026amp; b) { cout \u0026lt;\u0026lt; \u0026#34; namespace:sx \u0026#34; \u0026lt;\u0026lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; }; } 命名空间的嵌套定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 namespace sx { int a; void swap(int\u0026amp; a, int\u0026amp; b) { cout \u0026lt;\u0026lt; \u0026#34; namespace:sx \u0026#34; \u0026lt;\u0026lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; }; namespace psm { int b; void print() { cout \u0026lt;\u0026lt; \u0026#34;hello psm!\u0026#34; \u0026lt;\u0026lt; endl; } } } 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合并成同一个命名空间中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 namespace n1 { int a; void swap(int\u0026amp; a, int\u0026amp; b) { cout \u0026lt;\u0026lt; \u0026#34;n1:swap\u0026#34; \u0026lt;\u0026lt; endl; } } namespace n2 { int b; } namespace n1 { int c; void swap(int\u0026amp; a, int\u0026amp; b) { cout \u0026lt;\u0026lt; \u0026#34;n1:swap\u0026#34; \u0026lt;\u0026lt; endl; } } 像这样子去定义编译时会报错：\n函数“void n1::swap(int \u0026amp;,int \u0026amp;)”已有主体\n删除其中一个即可正常编译，由此可见编译时两个名字相同的命名空间会合并，如果有重复的定义则会报错。\n注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。\n命名空间的使用 定义在命名空间中的变量、类型以及函数我们是无法直接使用的，由于命名空间就定义了一个新的作用域，而程序中默认是只使用两个作用域的内容的：\n全局作用域 局部作用域 并且根据局部优先原则会程序会先检索当前作用域的内容，如果没有找到我们需要的，再到全局域去检索，所以默认情况下我们所定义的命名空间的作用域的内容我们是无法直接访问的。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace sx { int a; void swap(int\u0026amp; a, int\u0026amp; b) { cout \u0026lt;\u0026lt; \u0026#34; namespace:sx \u0026#34; \u0026lt;\u0026lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; }; } int main() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//该语句编译出错，无法识别a return 0; } 报错：“a”: 未声明的标识符\n命名空间的使用方式有三种：\n加命名空间名称及作用域限定符 1 2 3 4 5 int main() { cout \u0026lt;\u0026lt; sx::a \u0026lt;\u0026lt; endl;//指定使用在sx这个命名空间中的a return 0; } 作用域限定符是临时的，因此每次使用时都需要加命名空间和作用域限定符（限定符限定的是成员的名称，因此限定符应紧挨着在成员名称的前面，例如：sx::Stu s）\n使用using声明命名空间中的成员，声明我们可以不加限定符使用此成员 1 2 3 4 5 6 7 8 using sx::a;//指定地将sx中的a引入 int main() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;\t//可以使用a Stu s;\t//无法使用Stu类型 return 0; } 这样只能使用指定使用我们需要的成员，并且声明时指定的应是成员的名称（变量名吗，函数名，类型名）。\n使用using namespace 将命名空间中的成员引入至全局域 1 2 3 4 5 6 7 8 using namespace sx; int main() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; Stu s; return 0; } 这种方法会将命名空间的所有成员一次性引入，可以直接访问其中所有的成员，平时我们可以这样使用，但是着违背了命名空间诞生的初衷，容易产生命名冲突的问题，因此在工程中通常是使用第一种或者第二种方法。\n如何证明命名空间是被引入至全局域的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int a = 1; using namespace sx; int main() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//“a”: 不明确的符号 return 0; } using namespace sx; int main() { int a = 1; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 第一个程序提示错误，而第二个程序正常运行。\n引入至全局域后我们的程序即可在全局域中找到定义在命名空间sx中的变量 a ，而我们本身又在全局域中定义了一个变量 a ，那么自然如果不指定是哪个域中的也就产生了歧义，使得a变量名指代不明确。\n可如果我们再次定义的a变量是局部的，即使命名空间中的a被引入至全局域，但并不会产生歧义，因为局部优先的原则，我们并不会去全局域中检索变量a，也就不存在命名冲突。\n注意：即使是引入至全局域，命名空间sx中的a和本身定义在全局的a是拥有各自的内存空间的，\u0026ldquo;引入\u0026quot;仅仅是让其在全局域中可被检索，它仍然是属于命名空间sx的，有点像环境变量，引入就像是将某个命令所在的路径添加至环境变量，环境变量路径中的命令是可以在计算机任何路径下使用的，然而其被使用的命令可能并不在当前路径，它们之间是相互独立的。\n指定使用全局域中的内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 namespace sx { int a; void swap(int\u0026amp; a, int\u0026amp; b) { int tmp = a; a = b; b = tmp; } } using namespace sx; int main() { int a = 1; cout \u0026lt;\u0026lt; ::a \u0026lt;\u0026lt; endl;//这里的a访问的是全局的 return 0; } 即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。\n命名空间是有一些比较坑的地方的，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //代码1 int a = 1; namespace sx { int a; void swap(int\u0026amp; a, int\u0026amp; b) { int tmp = a; a = b; b = tmp; } } using namespace sx; int main() { cout \u0026lt;\u0026lt; ::a \u0026lt;\u0026lt; endl; return 0; } //代码2 int a = 1; namespace sx { int a; void swap(int\u0026amp; a, int\u0026amp; b) { int tmp = a; a = b; b = tmp; } } using sx::a; int main() { cout \u0026lt;\u0026lt; ::a \u0026lt;\u0026lt; endl; return 0; } 代码1可以正常运行，而代码2却显示a多次定义，个人觉得还是有些奇怪的，不过项目中我们并不会将命名空间展开，更不会有这样的写法。使命名空间变量具有与全局变量相同的名称是错误的（参考微软官方文档https://docs.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170）。因此不用过于纠结这里的差异。\n总之，使用using将命名空间展开或者是声明成员，即代表着后续的代码可以使用此命名空间的成员。\nC++输入输出 向世界打个招呼！\n1 2 3 4 5 6 7 8 #include\u0026lt;iostream\u0026gt; using std::cout; int main() { cout \u0026lt;\u0026lt; \u0026#34;hello world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 使用cout标准输出(控制台)和cin标准输入(键盘)时，必须包含\u0026lt; iostream \u0026gt;头文件以及std标准命名空间。\n注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持\u0026lt;iostream.h\u0026gt;格式，后续编译器已不支持，因此推荐使用\u0026lt;iostream\u0026gt; +std的方式。\n使用C++输入输出更方便，它会自动识别类型（函数重载实现）而不需增加数据格式控制，比如：整形\u0026ndash;%d，字符\u0026ndash;%c\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; //using namespace std; using std::cout; using std::endl; using std::cin; int main() { int i = 1; double d = 1.1; cout \u0026lt;\u0026lt; \u0026#34;i =\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;,d =\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 但是C++的这样的输入输出方式在有些场景下使用会非常麻烦，而C语言就会很方便，例如左对齐右对齐或者是保留几位小数这样的场景，推荐使用C语言的输出方式printf函数。\n缺省参数 缺省参数即可有可无的参数，就像汽车备胎，带上备胎也能上路不带也不影响，除非运气实在太差。\n缺省参数是声明或定义函数时为函数的参数指定一个默认值，在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。\n1 2 3 4 5 6 7 8 9 10 11 void testfunc(int t = 10) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } int main() { testfunc(100);//传入100，就使用指定的实参 testfunc();//没有实参，就使用默认的形参10 return 0; } 缺省参数的分类 全缺省参数 ​\t即所有参数都有自己的默认值，传参时可以全部省略。\n1 2 3 4 5 6 7 8 9 10 void FAll(int x = 1, int y = 2, int z = 3) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; y \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } int main() { FAll();//全缺省 return 0; } 半缺省参数 ​\t即只有部分参数都有自己的默认值，传参时一定需要传参。\n1 2 3 4 5 6 7 8 9 void FHalf(int x, int y = 10, int z = 30) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; y \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } int main() { FHalf(5);//半缺省 return 0;p } 注意：\n半缺省参数只能依次从右到左且连续，因为形参是从左往右依次传给实参，所以必须保证没有默认值的实参一定能有形参传值给它。 缺省参数不能在定义和声明中同时出现，以免给的默认值不同产生歧义。 1 2 3 4 5 6 void Test(int a = 10); void Test(int a = 20)//报错 { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } 缺省值必须是常量或者是全局变量 C语言不支持 注意：如果定义和声明分离，那么只能缺省在声明\n如果缺省参数在定义中，而声明没有，那么声明的头文件展开后，由于声明和定义在不同的源文件中，它们会先分别编译，那么包含定义的那个源文件在编译时编译器认为该函数是没有缺省参数的，但是该源文件函数的调用却没有传入参数，就发生了编译错误。\n函数重载 在我们的中文中常常会有一词多义的情况，但是我们可以通过上下文来帮助我们判断并确定它所表达意义而不是让我们无法识别。\n讲个笑话：\n我国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！\n那么一个相同的函数名我们想让它不只是有一种功能或者是不止能处理一种特定情况呢，函数重载可以帮助我们解决这个问题。\n函数重载的概念 函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数或 类型或顺序)必须不同，常用来处理实现功能类似但数据类型不同的问题。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;int Add(int a, int b)\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } double Add(double a, double b) { cout \u0026lt;\u0026lt; \u0026#34;double Add(double a, double b)\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } float Add(float a, float b) { cout \u0026lt;\u0026lt; \u0026#34;float Add(float a, float b)\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } int main() { int ret1 = Add(1, 2); int ret2 = Add(1.1, 2.2); int ret3 = Add((float)1.1, (float)2.2); return 0; } 输出：\n相同的函数名传入不同类型的参数调用的函数实体不同。\n注意：无法区分仅按返回类型区分的函数\n例如：\n1 2 3 4 5 6 7 8 short Add(short left, short right) { return left + right; } int Add(short left, short right) { return left + right; } 因为函数调用时只能根据实参的类型去找相匹配的函数，而无法识别返回类型。\n函数重载的底层实现 C语言是不支持函数重载的，但是C++却引入了这个特性，那么一定是因为底层实现有区别，于是我们从程序的编译和运行来探索一下，一个程序要运行起来，那么必须要经过预处理、编译、汇编、链接最终成可执行文件，在Windows中是后缀为 exe的文件，但由于VS是集成环境不方便查看，我们可以在Linux环境下尝试。\n程序的编译过程：\n符号表的合并\n实际我们的项目通常是由多个头文件和多个源文件构成，而通过我们C语言阶段学习的编译链接，我们可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标文件中没有Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？\n所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符号表中找Add的地址，然后链接到一起。\n那么链接时，面对Add函数，连接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。\n【程序的编译具体参见】：\n【C语言进阶】程序的编译 – Sabrina\n函数名修饰\n由于Windows下vs的修饰规则过于复杂，而Linux下gcc的修饰规则简单易懂，下面我们使用了gcc演示了这个修饰后的名字。 通过下面我们可以看出gcc的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度+函数名+参数类型首字母】。 分别使用C的编译器和C++的编译器去编译并获得一个可执行文件\n使用C语言（gcc）编译器编译后结果 使用objdump -S 命令查看gcc生成的可执行文件：\n使用C++编译器（g++）编译后结果 使用objdump -S 命令查看g++生成的可执行文件：\nlinux下：修饰后的函数名= _Z + 函数名长度 + 形参类型首字母\n通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载，另外我们也从底层理解了，为什么函数重载要求参数不同！而跟返回值没关系。\nC++的编译和链接方式\n采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数，而我们另一个模块中想要调用这些函数也就必须使用相对应的C++的规则去链接函数（找修饰后的函数名）才能找到函数的地址。\nC的编译和链接方式\n对于C程序，由于不支持重载，编译时函数是未加任何修饰的，而且链接时也是去寻找未经修饰的函数名。\nC和C++直接混合编译时的链接错误\n在C++程序中，函数名是会被参数类型信息修饰的，这就造成了它们之间无法直接相互调用。\n例如：\nprint(int)函数，使用g++编译时函数名会被修饰为 _Z5printi，而使用gcc编译时函数名则仍然是print，如果直接在C++中调用使用C编译规则的函数，会链接错误，因为它会去寻找 _Z5printi而不是 print。\n结论：在Linux环境下，采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数。\n对重载函数的调用不明确 难道说有了重载函数那么函数在调用时即使函数名相同就一定能区分了吗？\n来看看下面这种情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void test(int a = 1, int b = 2) { cout \u0026lt;\u0026lt; \u0026#34;testab\u0026#34; \u0026lt;\u0026lt; endl; } void test() { cout \u0026lt;\u0026lt; \u0026#34;test\u0026#34; \u0026lt;\u0026lt; endl; } int main() { test(); return 0; } 那么在12行调用test函数，按照C++的链接规则，我们应该找的是_Z4test，这样的被修饰过的函数名。\n第1行的test函数经过修饰是_Z4testii\n第6行的test函数经过修饰是_Z4test\n那是否意味着我们不传参调用时就一定去找的_Z4test呢？但是明明第1行的函数带有默认参数即使不传参也可以调用啊。\n事实上这个程序是可以编译通过的因为被修饰后的函数名并不会产生冲突，只会在调用函数时会存在歧义，链接过程中，这两个重载的函数都会成为被调用的候选人，并且都符合调用的条件，多个匹配函数找到，调用将被拒绝，因此我们链接过程中不仅仅是寻找函数名那么简单，还有很多复杂的规范。\n【拓展阅读】：C++的函数重载 - 吴秦 - 博客园\nextern “C” 我们在写C++代码时，由于其兼容C语言，因此我们通常会使用一些C标准库里的函数，那如果它们的函数名修饰规则不同，那么C++编译器又是怎么去调用C的库的呢？\n在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern \u0026ldquo;C\u0026quot;就是其中的一个策略.\n在C++工程中需要将某些函数按照C的风格来编译，在函数前加extern \u0026ldquo;C\u0026rdquo;，意思是告诉编译器，该函数是按照C语言规则来编译和链接的。\n比如：tcmalloc是google用C++实现的一个项目，他提供tcmallc()和tcfree,两个接口来使用，但如果是C项目就没办法使用，那么他就使用extern “C”来解决。\n源文件A（cpp）:\n1 2 3 4 int Add(int num1, int num2) { return num1 + num2; } 源文件B（cpp）:\n1 2 3 4 5 6 extern \u0026#34;C\u0026#34; int Add(int num1, int num2); int main() { Add(1, 2);//在模块B中调用A中的函数 return 0; } error LNK2019: 无法解析的外部符号_Add，该符号在函数 _main 中被引用\n注意：\n这里的模块A的 Add函数仍然是按照C++规则去编译的，函数名仍会被修饰为_Z3Addii，不过在模块B 使用extern ”C“会让编译器让Add函数按照C的方式链接，所以在调用时用C的方式去寻找Add，所以会报错。\n总结：\nextern \u0026ldquo;C\u0026rdquo; 只是 C++ 的关键字，不是 C 的\n所以，如果在 C 程序中引入了 extern \u0026ldquo;C\u0026rdquo; 会导致编译错误。\n被 extern \u0026ldquo;C\u0026rdquo; 修饰的目标一般是对一个全局C或者 C++ 函数的声明\n从源码上看 extern \u0026ldquo;C\u0026rdquo; 一般对头文件中函数声明进行修饰。 C 和 cpp 中头文件函数声明的形式都是一样的（因为两者语法基本一样），对应声明的实现却可能由于语言特性而不同了( C 库和 C++ 库里面当然会不同)。\nextern \u0026ldquo;C\u0026rdquo; 这个关键字声明的真实目的，就是实现 C++ 与C及其它语言的混合编程\n一旦被 extern \u0026ldquo;C\u0026rdquo; 修饰之后，它便以 C 的方式工作（编译阶段：以C的方式编译，链接阶段：寻找C方式编译生成的符号）， C 中引用 C++ 库的函数，或 C++ 中引用 C 库的函数，都可以通过这个方式(即在C++文件中用extern \u0026ldquo;C\u0026rdquo; 声明，实现C与C++的兼容。\n【关于extern “C”的具体使用】：\nC++和C的混合编译（extern“C”） – Sabrina\n引用 引用的概念 引用不是定义了一个新的变量，而是是一个别名，也就是说，它是某个已存在变量的另一个名字，它和被引用的对象共用同一块内存空间。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n别名字面意思就是另一个名字，例如孙悟空，他的别名是孙行者，孙悟空也是他，齐天大圣也是它，一切可以指代他的名称都可以称作他的别名。\n初始化引用格式\n引用实体类型 \u0026amp; 引用变量名 = 引用实体\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 1; int\u0026amp; quote = a;//初始化quote为a的别名 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; quote \u0026lt;\u0026lt; endl; quote = 2; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; quote \u0026lt;\u0026lt; endl; return 0; } 我们进入调试窗口：\n通过调试可以看到，a和quote的地址是一样的，并且quote的类型就为int\u0026amp;，所以quote的改变一定会影响a。\n引用特性 引用在定义时必须初始化； 一个变量可以有多个引用； 引用一旦引用一个实体，引用指向的对象就不能再改变； 引用的实体可以是另一个引用; 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; //定义引用时未初始化 int main() { int a = 1; int\u0026amp; quote;//未初始化引用，error: ‘rodents’ declared as reference but not initialized quote = a; } //修改引用实体 int main() { int a = 1; int b = 2; int\u0026amp; quote = a; int\u0026amp; quote = b;//只能引用一个实体,编译出错 return 0; } //引用另一个引用 int main() { int a = 1; int\u0026amp; quote1 = a; int\u0026amp; quote2 = quote1;//它们的地址仍然相同，指向同一块空间 return 0; } 常引用 在C++中，与C语言不同，被const修饰的变量会被当做是一个常量（只对该变量内存空间有读权限，没有写权限），而不是常变量，因此引用的类型一定要和被引用的实体相匹配，可以有权限的缩小，但不能有权限的扩大。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //权限的缩小 int main() { int a = 1; const int\u0026amp; quote = a;//从可读可写-》只可读 return 0; } //权限的放大会报错 int main() { const int a = 1; int\u0026amp; quote = a;//从只可读-》可读可写 return 0; } //常引用 int main() { const int a = 1; const int\u0026amp; quote = a; quote = 2;//不可赋值 return 0; } 使用场景 做参数 ​\t对于需要在函数内部修改函数外部实参的函数，让形参为实参的引用，就可以在函数内部修改外部变量，并且\t还可以减少形参拷贝实参的开销。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void swap(int\u0026amp; num1, int\u0026amp; num2) { int tmp = num1; num1 = num2; num2 = tmp; } int main() { int n1 = 3; int n2 = 5; swap(n1, n2); cout \u0026lt;\u0026lt; \u0026#34;n1=\u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;n2=\u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; return 0; } 做返回值 如果返回的变量在函数调用结束后不会被自动销毁，则可以返回该变量的引用，减少返回值拷贝的开销\n1 2 3 4 5 6 7 int\u0026amp; count() { static int n = 1; ++n; cout \u0026lt;\u0026lt; \u0026#34;int\u0026amp; count()\u0026#34; \u0026lt;\u0026lt; endl; return n; } 返回值不能是函数内创建的局部变量的引用 ​\t否则会非法访问内存（访问不属于程序的内存）\n1 2 3 4 5 6 7 8 9 10 11 12 int\u0026amp; Add(int a, int b) { int c = a + b; return c; } int main() { int\u0026amp; ret = Add(2, 8);//Add(2, 8)的类型是c的引用，当赋值给ret时，c变量已经销毁 cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 总结：如果函数调用结束后栈帧销毁但是返回对象仍未销毁，则可以使用引用返回，否则只能传值返回。\n传值和传引用的区别 以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。\n函数的传参如果是传值调用的话，形参实际上是实参的一份拷贝，也就是说每一次调用函数，都要将实参拷贝给形参，这也带来了资源的消耗，如果多次调用此函数，那么必定会导致效率的低下。\n可以使用如下代码测试多次调用函数时传值调用和传引用调用的时间差异\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;iostream\u0026gt; #include\u0026lt;time.h\u0026gt; using namespace std; struct A { A() { memset(arr, 0, sizeof(arr)); } int arr[1000]; }; void TestFunc1(A p) {} void TestFunc2(A\u0026amp; p) {} void TestEfficiencyByCall() { A p; size_t start1 = clock(); for (int i = 0; i \u0026lt; 1000000; i++) { TestFunc1(p); } size_t end1 = clock(); size_t start2 = clock(); for (int i = 0; i \u0026lt; 10000; i++) { TestFunc2(p); } size_t end2 = clock(); cout \u0026lt;\u0026lt; \u0026#34;传值调用 void TestFunc1(A p)：\u0026#34; \u0026lt;\u0026lt; end1 - start1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;传引用调用 void TestFunc1(A\u0026amp; p)：\u0026#34; \u0026lt;\u0026lt; end2 - start2 \u0026lt;\u0026lt; endl; } int main() { TestEfficiencyByCall(); return 0; } 运行结果如下：\n值和引用的作为返回值类型的性能比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 struct A { A() { memset(arr, 0, sizeof(arr)); } int arr[1000]; }; A a; A TestFunc1() { return a; } A\u0026amp; TestFunc2() { return a; } void TestEfficiency() { size_t start1 = clock(); for (int i = 0; i \u0026lt; 1000000; i++) { TestFunc1(); } size_t end1 = clock(); size_t start2 = clock(); for (int i = 0; i \u0026lt; 10000; i++) { TestFunc2(); } size_t end2 = clock(); cout \u0026lt;\u0026lt; \u0026#34;值返回 void TestFunc1(A p)：\u0026#34; \u0026lt;\u0026lt; end1 - start1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;引用返回 void TestFunc1(A\u0026amp; p)：\u0026#34; \u0026lt;\u0026lt; end2 - start2 \u0026lt;\u0026lt; endl; } int main() { TestEfficiency(); return 0; } 运行结果：\n可以看到无论是作为参数还是作为返回值，传递引用和值的时间的开销差异都是比较大的。\n我们可以看一看函数返回值是如何传递的：\n函数返回值从被调用的函数的栈帧到调用方栈帧的传递过程大致如上。\n通常我们会创建一个变量接收函数得返回值，在这里就是这个在main函数中预先开好空间的用于存储函数返回值的对象。\n接下来看过程：\n如果是传值返回，则产生的临时变量会是返回对象的一份临时拷贝，然后再拷贝给main函数中预先开好空间的用于存储函数返回值的对象，而如果是传引用返回，则临时变量会是a的引用，临时对象再赋值给main函数中预先开好空间的用于存储函数返回值的对象，那这里也会是一个引用，因此我们在main函数中就可以访问到a对象了。\n不过不是每次都需要创建一个临时变量，对于一些比较小的变量，会直接用寄存器来传递值。\n注：临时变量的类型就是定义的返回类型，此临时变量通常也是也是具有常性的，不过也有例外，那就是传引用返回的情况。\n传值返回：那么该临时变量是有常性的。 传引用返回：无常性，只和返回的类型是否被const修饰有关。 临时变量存储于调用方函数的栈帧**。\n引用和指针的区别 引用很容易与指针混淆，它们之间有三个主要的不同：\n不存在空引用（引用的对象必须存在）。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 引用在语法层面上就是一个别名，别名是不单独享有内存空间的，它和被引用的实体共用同一块内存空间。\n1 2 3 4 5 6 7 8 int main() { int a = 9; int\u0026amp; ra = a; cout \u0026lt;\u0026lt; \u0026#34;\u0026amp;a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\u0026amp;ra = \u0026#34; \u0026lt;\u0026lt; \u0026amp;ra \u0026lt;\u0026lt; endl; return 0; } 这样的语法解释实在有些难以理解它在底层是如何做到的。\n实际上在底层实现上引用还是有空间的，因为引用本质还是指针的方式来实现的。\n1 2 3 4 5 6 7 8 9 10 11 int main() { int a = 9; int\u0026amp; ra = a; ra = 99; int* pa = \u0026amp;a; *pa = 99; return 0; } 我们来看看汇编：\n汇编指令大致都是相同的，也就是说它和指针实际上是同根同源的。\n指针和引用差异汇总：\n引用在定义时必须初始化，而指针不需要； 引用在初始化引用一个实体后就不能再引用其他实体了，而指针指向的对象可以随意修改； 没有NULL引用，但是又NULL指针； 在sizeof中的含义不同，引用结果为被引用实体的类型大小，而指针的大小是地址空间所占的字节数； 引用在初始化后，一切对引用的操作都是对实体对象操作的，而指针可以操作指针变量本身，也可以操作被指向的对象； 有多级指针但没有多级引用； 访问实体方式不同，指针需要我们显式的去解引用方能对指向的对象进行操作，而引用是编译器替我们处理； 引用相对于指针更加的安全，不存在野指针等潜在的风险； 一些引用的注意事项 类型转换实现方法以及临时变量的特性\n看如下代码：\n1 2 3 4 5 6 7 int main() { double d = 9.9; int\u0026amp; a = d; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 报错：\n“初始化”: 无法从“double”转换为“int \u0026amp;”\n改动如下即可正常编译：\n1 2 3 4 5 6 7 int main() { double d = 9.9; const int\u0026amp; a = d; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 这是什么原因？？const修饰过后为什么就能正常编译了呢？？？（warning）\n这里不得不提到类型转换时发生的小动作；\n类型转换是如何实现的呢？不论是显式的还是隐式的发生的类型转换，它这个类型转换的效果都是“临时”的，仅仅在当前行生效，也就是说本身发生转换的那个变量或者说是对象它的类型并没有改变。\n既然如此，那么中间一定会有另一个临时变量的产生，而是这个我们看不到的临时变量在发挥让我们看起来像**“类型转换”**的作用。\n那么再来看第4行代码，int\u0026amp;只能初始化为int类型的引用，因此这里会发生隐式类型转换，即产生一个int类型的变量，并且让这个临时变量在这一行中代替d来产生作用，a就被初始化为了这个临时变量的引用；\n为什么不用const修饰就无法通过编译呢？\n答案是：临时变量具有常性，也就是说临时变量具有只可读不可写的性质，那么如果不使用const对引用加以限制，就造成了权限的放大，而这是不被C++所允许的，因此必须加上const修饰a；\n嘿，那么新问题来了，既然临时变量只在当前行生效，也就是程序走完这一行临时变量就销毁了，而a作为此临时变量的引用，却在第5行正常访问了a，那么这里我们还可以得出一个结论：\nconst修饰的引用的实体是临时变量时，临时变量的声明周期就会延长，直到引用的生命周期结束。\n概括一下：\n类型转换伴随着临时变量的产生； 临时变量具有常性； const修饰的引用的实体是临时变量时，临时变量的声明周期就会延长，知道引用的生命周期结束； 不会被修改的变量尽量用const修饰； 关于临时对象的类型的注意事项\n如下两段代码有何差异？\n1 2 3 4 5 6 7 8 9 //代码1 int main() { double d = 9.9; const int\u0026amp; a = (int\u0026amp;)d; cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 输出：\nd = 9.9 a = -858993459\n1 2 3 4 5 6 7 8 9 //代码2 int main() { double d = 9.9; const int\u0026amp; a = d; cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 输出：\nd = 9.9 a = 9\n出错了，奇怪，这两段代码的执行结果应该相同才对啊？？？不急我们耐心分析一下这两段代码的差异。\n差异就只有第四行，我们来单独看看\n代码1：\nconst int\u0026amp; a = (int\u0026amp;)d;\n这行代码的意思应该是将 d (double类型)强制类型转换为 int\u0026amp;，我们都知道强转类型时会生成一个临时变量（int\u0026amp;），再初始化a为为这个临时变量的引用；\n关系如图：\n这里的关系文字描述为d是double类型， tmp是d的引用（int\u0026amp;），而a又是tmp的引用（int\u0026amp;），可以直接认为a是d的引用，只不过引用的类型为 const int;\n代码2：\nconst int\u0026amp; a = d;\n这行代码的意思是初始化a为d的引用，不过类型并不匹配，int\u0026amp;需要一个引用一个int的实体或者一个int\u0026amp;的引用，因此，d会发生隐式类型转换，产生一个int类型的临时变量，即a会是这个临时变量的引用。\n关系如图：\n这里的关系文字描述为d是double类型，而tmp是一个临时的int类型，a是tmp的引用；\n这样就解释的通了，但是是否真是如此，我们需要通过地址来验证；\n代码1：\n可以看到他d和a的地址是一样的，说明a是d的引用（指向d的地址），但只是引用的类型和d的类型不同。\n代码2：\na的地址和d不同，这是因为a是隐式类型转换所产生的临时变量的引用，而此临时变量是一个int类型，而非引用，具有自己独立的内存空间，而a指向这块临时变量的空间，因此地址不同。\n这两段代码的唯一差异就是类型转换时生成的临时变量的类型不同，一个是int类型，一个是int\u0026amp;类型，即一个有自己的单独内存空间，而另一个与发生类型转换的对象共享一块空间（其实引用是有单独的内存空间，不过经过编译器处理，我们对引用操作时都是实际上操作的是被引用的实体，因此可以视作没有分配内存），而a都是临时变量的引用，就导致了最终结果的不同。\n因此在使用引用时，一定要注意这些可能会遇到的问题，一不留神就可能掉坑了，要规范正确的使用引用。\n","date":"2022-12-05T17:11:58Z","permalink":"https://stack.xinsong.xyz/p/c-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E4%B8%8A/","title":"C++入门基础上"},{"content":" 转载自：【教程】VScode中配置C语言/C++运行环境_哔哩哔哩_bilibili\n下载编辑器VScode 官网：https://code.visualstudio.com/\n安装VScode（建议附加任务全部勾选）\n下载编译器MinGW并解压 官网页面：https://www.mingw-w64.org/\n下载页面：https://sourceforge.net/projects/mingw-w64/files/ -内置了iconv工具\n非官方下载页面：MinGW Distro - nuwen.net -此版本未内置iconv工具\n你可以进入官网自行寻找\n你也可以直接点击为你找好的下载页面\n下载页面中选择 x86_64-win32-seh 下载\n如果你因为网络环境限制无法下载\n不限速下载，请笑纳^-^：https://wwn.lanzouh.com/iLOip031ku6b 密码:1234\n在C盘中解压文件\n理论上你可以在任何地方解压，但注意路径不能包含中文，至于特殊字符请自行测试\n将MinGW添加至环境变量 进入mingw64下的bin文件夹，复制当前路径，Win + i唤起系统设置，输入高级系统设置并进入，点击环境变量，选择path，编辑，新建，粘贴路径，按下三个确定\n配置VScode插件 打开VScode安装插件 Chinese 和 C/C++ ，等待安装完毕后重启VScode\n切换C/C++插件至 1.8.4 版本（非必要，不过对于小白来说更方便，此版本运行即自动配置）\n因最新版本不会自动生成launch.json文件，给后续优化带来不便，故退回旧版本。\n运行代码 新建文件夹，修改为英文名称并进入，右键 通过Code打开 若在安装时未勾选相关选项，可能没有这个选项，请自行在VScode内操作打开文件夹\n新建一个文件，英文命名且扩展名为 .c\n编写相关代码\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); printf(\u0026#34;你好世界！\\n\u0026#34;); system(\u0026#34;pause\u0026#34;); // 防止运行后自动退出，需头文件stdlib.h return 0; } VScode菜单栏，点击运行，启动调试，稍等程序运行，输出结果在下方终端，上方调试面板，点击最右边的 橙色方框 停止程序运行\n调整和优化 请根据自己的需要进行优化\n代码运行后 .vscode 文件夹会自动生成在你的源文件目录下\n.vscode 文件夹下的 task.json 和 launch.json 用来控制程序的运行和调试\n将程序运行在外部控制台【墙裂推荐】\n打开.vscode 文件夹下的 launch.json 文件，找到 \u0026quot;externalConsole\u0026quot;: false, 将 false 改为 true 并保存\n解决中文乱码问题【墙裂推荐】| VSCode中解决终端的中文乱码问题 - 我等着你 - 博客园\n中文乱码是由于VSC的默认编码格式是UTF-8，那么编译后程序的字符串的保存方式仍然为UTF-8，而CMD的编码方式为GBK。GBK的编码中文和符号是双字节，字符和整型是单字节。utf-8的中文和符号是三字节，字符和整型是单字节，二者的中文字符并不兼容。为解决这个问题，我们需要将二者的编码方式设为相同编码。方法多种多样，最方便、副作用最小的是下面将要介绍的方法：\n先了解一下gcc编译选项：\n-finput-charset:输入字符集设置(需要和源文件编码一致)，告诉编译器以什么样的编码形式读入源文件中的字符串。\n-fexec-charset:执行字符集设置(需要设置为当前运行环境支持的编码),告诉编译器在内存中以什么样的编码形式保存字符串。\n-fwide-exec-charset:宽字符执行编码(在windows下应设置为utf-16LE)，告诉编译器在内存中以什么样的编码形式保存宽字符串。\n修改程序编码方式为GBK：\n打开.vscode 文件夹下的 task.json 文件，找到 \u0026quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026quot; 在后面加上英文 逗号 然后回车到下一行，粘贴下面文本 \u0026quot;-fexec-charset=GBK\u0026quot; 并保存\n编译时用\u0026quot;-fexec-charset=GBK\u0026quot;这个参数（目前的配置是有的），生成的程序的字符串就是GBK编码的，源文件编码格式不会受到影响，仍是UTF-8。\n注意：加入此参数需要依赖你下载的mingw内置iconv工具！！！\niconv是一个计算机程序以及一套应用程序编程接口的名称。 作为应用程序的iconv采用命令行界面，允许将某种特定编码的文件转换为另一种编码。\n若缺少iconv工具使用了此参数，会出现如下报错：\n1 no iconv implementation, cannot convert from utf-8 to gbk 收纳生成的 exe 可执行文件【可选】\n打开.vscode 文件夹下的 task.json 文件，找到 \u0026quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026quot;\n修改成 \u0026quot;${fileDirname}\\\\coin\\\\${fileBasenameNoExtension}.exe\u0026quot; 并保存，同理，launch.json 下也有相同的字段，需要你修改\n在源文件同目录下新建 coin 文件夹，程序运行后，可执行文件将会生成在里面（其中 coin 可修改成你喜欢的英文名字）\n这样 .c 文件一多起来的时候，就不会出现 .exe 和 .c 相互穿插在目录中^-^\n​\t以上优化C++的项目同理，不再演示。\n提示 若源代码文件夹含有中文路径，将会无法编译程序。 若你的Windows用户名使用了中文，可能无法运行。 ","date":"2022-12-05T17:08:35Z","permalink":"https://stack.xinsong.xyz/p/vscode%E9%85%8D%E7%BD%AEc-c-%E7%8E%AF%E5%A2%83/","title":"VSCode配置C-C++环境"},{"content":"简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n安装hexo 安装hexo之前需要安装Nodejs组件，这个在我的另一篇文章：\nHexo是我们博客的框架，我们需要在我们的电脑里创建一个文件夹，可以命名为Blog，Hexo框架与你发布的博客网页以后都会在这个文件中。创建好后进入文件夹中，按住shift键，右键鼠标点击打开powershell窗口；\n打开后\n使用npm命令安装Hexo，命令行窗口输入：\n1 npm install -g hexo-cli 等待一会儿即可，接着输入命令初始化我们的博客：\n1 hexo init blog 上面的两个命令都作用于我们刚刚创建的Blog文件夹。\n然后我们就可以看到我们的Blog/文件夹目录下会出现一个blog文件夹，接着我们进入blog文件夹；\n输入命令：\n1 cd blog 接下来我们来检测我们网站的雏形，依次输入以下命令；\n1 2 3 4 5 hexo new test_my_site hexo g hexo s 刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。\n在浏览器地址窗口输入：localhost:4000\n即可访问到我们本地的博客内容。\n未经修改过的博客页面应该是上面这个样子的，也可以看到我们刚刚创建的test_my_site这篇文章。\n这样就说明我们本地的博客页面是正常的。\n现在来介绍常用的Hexo 命令\nnpm install hexo -g #安装Hexo npm update hexo -g #升级 hexo init #初始化博客\n命令简写 hexo n \u0026ldquo;我的博客\u0026rdquo; == hexo new \u0026ldquo;我的博客\u0026rdquo; #新建文章 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署\nhexo server #Hexo会监视文件变动并自动更新，无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令\n推送网站 刚刚我们看到的只是我们本地的预览，别人并无法访问，接下来要做的就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。\n创建Github仓库 进入Github网页创建一个新仓库，点击New repository\n仓库名为固定格式： Github用户名.github.io\n例如我的sxfinn.github.io\n我们使用 ssh 免密部署，这种方式可以避免输密码的繁琐，并且速度也是最快的。\n创建密钥对 为了方便运行 GitHub Actions 时登录 GitHub 账号，我们使用 SSH 方式登录。就是要把设备的私钥交给 GitHub Actions，公钥交给 GitHub，需要去 Settings 里去配置。\n进入git bash\n1 2 3 ssh-keygen -t rsa -C \u0026#34;Github的邮箱地址\u0026#34; # 例如 ssh-keygen -t rsa -C \u0026#34;123123123@gmail.com\u0026#34; 代码参数含义：\n-t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。\n输入后接着按三个回车\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [root@localhost ~]# ssh-keygen -t rsa \u0026lt;== 建立密钥对，-t代表类型，有RSA和DSA两种 Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): \u0026lt;==密钥文件默认存放位置，按Enter即可 Created directory \u0026#39;/root/.ssh\u0026#39;. Enter passphrase (empty for no passphrase): \u0026lt;== 输入密钥锁码，或直接按 Enter 留空 Enter same passphrase again: \u0026lt;== 再输入一遍密钥锁码 Your identification has been saved in /root/.ssh/id_rsa. \u0026lt;== 生成的私钥 Your public key has been saved in /root/.ssh/id_rsa.pub. \u0026lt;== 生成的公钥 The key fingerprint is: SHA256:K1qy928tkk1FUuzQtlZK+poeS67vIgPvHw9lQ+KNuZ4 root@localhost.localdomain The key\u0026#39;s randomart image is: +---[RSA 2048]----+ | +. | | o * . | | . .O + | | . *. * | | S =+ | | . =... | | .oo =+o+ | | ==o+B*o. | | oo.=EXO. | +----[SHA256]-----+ 密钥对生成后默认的位置是用户文件。以 windows 为例：密钥对文件在 C:\\Users\\用户名里，其中 Users 可能因为系统原因显示的是用户。这个文件夹里会有一个.ssh 的目录，这个里面就是我们的密钥对。\n其中 id_rsa 是私钥，id_rsa.pub 是公钥。\n配置公钥，应该已经配好，不然如何上到的项目资源，配置路径：github 网站–\u0026gt;Settings–\u0026gt;SSH and GPG keys\n新增一个公钥点击 Add SSH key，然后把 id_rsa.pub 这个文件用文本文档打开，将内容复制进去。\n使用下面的命令测试是否成功：\n1 ssh -T git@github.com 出现如下信息则说明添加成功。\n配置部署信息 在配置之前我们要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，之后我们对博客配置的修改都是通过此文件来进行的。\n如下图：\n现在我们要做的就是将Hexo与Github关联起来，打开站点的配置文件_config.yml，下拉到最后修改为：\n1 2 3 4 deploy: type: git repo: 你的地址 branch: master 注意：repo一行中“你的地址”，即为你刚刚创建的GitHub仓库的ssh链接。\n例如我的：\n保存站点配置文件。\n我们刚刚配置的文件其实就是在我们执行推送到远端这个hexo d这个命令时，让hexo知道该推送到哪里去，很显然我们部署在我们的GitHub仓库里。\n安装Git部署插件，输入命令：（仍然是Blog/blog 目录下）\n1 npm install hexo-deployer-git --save 一定要记得执行此命令否则无法自动部署。\n这时我们输入三条命令：\n1 2 3 4 5 hexo clean hexo g hexo d 其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即你刚刚创建的仓库名。\n你就会发现你的博客已经上线了，可以在网络上被访问了，这与你在本地预览的博客内容是一样的。\n绑定域名 虽然在网络上已经可以访问到我们的网站了，但我们大多数人都还是想使用自己的个性域名来访问网站的，这就需要绑定我们的域名。接下来我将演示阿里云域名绑定。其他厂商区别也都不大，可以作为参照。\n登录到阿里云，进入域名控制台点击解析； 添加解析记录 方案一（建议）：如果是想用主域名和www的域名访问站点\n需要添加两个解析记录：\n第一个解析记录的记录类型为A，主机记录为@，记录值为ping 你的github用户名.github.io的ip地址，填入为下列 IP 中的至少一个\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 第二个解析记录的记录类型为CNAME，主机记录为www，记录值为你的新建的仓库名——你的github用户名.github.io\n注意：这里直接添加两个CNAME一个类型为@另一个为www都指向 你的github用户名.github.io 也可以的（但主机记录为@的域名添加CNAME记录值可能会有与其他服务，例如电子邮件的冲突问题，因此不建议）\n方案二：如果是想使用单独的一个二级域名（包括www域）如blog域名访问站点\nCustom domain填入相应域名再添加一个解析记录，记录类型为CNAME，指向 你的github用户名.github.io 即可。\n方案三：如果是单独的只想使用主域名访问站点\n添加解析记录的记录类型为A，主机记录为@，记录值为ping 你的github用户名.github.io的ip地址，填入为下列 IP 中的一个至少一个\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 Page的自动双重定向 如下图添加了我们填写的Custom domain的解析记录会报错：DNS valid for primary，并且提示我们www域名未正确配置，这是为何？\n带着些历史原因，通常我们的印象中www域名和主域名是访问同一个站点的，大部分网站都这个机制，包括Github Page。\n这段时间搞了几种框架的网站建设了，我发现不是域名指向站点的 IP 就能访问站点。\n以typecho搭建的网站为例，即使一个域名指向了我们的 IP ，但如果我们的站点中没有保存这个域名的信息，也就是没有添加此域名作为访问站点的域名，那么这个域名仍然无法访问我们的站点，也就是说访问站点时是有域名认证的~，能解析到我的 IP 和站点还不行，我的站点还必须认证了此域名。\n利用GitHub page部署网站也有一个这个问题，那就是page的 IP 就那么4个，是如何能够访问我们的站点而不是其他人的站点呢？实际上GitHub是根据我们提交的CNAME去确定我们的站点的，CNAME的值会去填充Custom domain，而这个Custom domain会和我们的站点形成一种绑定关系，我们只有使用这个Custom domain才能正确访问站点。\n既然只能通过这一个Custom domain来访问站点，那么Github Page是怎么实现的www域名和主域名都能访问站点这样的机制呢？\n原因是Github Page提供了双重定向的机制。\nGitHub Page推荐我们通过DNS提供商在配置一个主域名同时配置一个 www 子域名，这样主域名和www的域名都可以访问站点\n如果您通过 DNS 提供商正确配置一个顶级域名（例如 example.com ）和一个匹配的 www 子域名（例如 www.example.com ），GitHub 服务器会自动地创建双重定向。\n正确配置这两个域名后：\n如果你的 CNAME 文件为 example.com，那么 www.example.com 会定向到 example.com。 如果你的 CNAME 文件为 www.example.com，那么 example.com 会定向到 www.example.com。 虽然只能填写一个Custom domain，也只能通过此Custom domain访问站点，但是通过DNS提供商对www域名和主域名DNS的正确配置GitHub Page会为我们自动创建双重定向，可以让 非Custom domain：www域 和主域其中一个 重定向到Custom domain，从而能够达到www域名和主域名都能访问站点的效果。而如果使用其他子域名（非www），则只能使用这一个子域名访问站点。自动重定向仅适用于www子域和其主域名之间，不适用于任何其他子域。\n例如，如果您将www.example.com站点配置为自定义域，并且为主域和www域设置了 GitHub Pages DNS 记录，example.com则将重定向到www.example.com,如果您将example.com站点配置为自定义域，并且为主域和www域设置了 GitHub Pages DNS 记录，www.example.com则将重定向到example.com.\n正是由于Page支持这样的机制，GitHub Page在我们Custom domain设置为 主域名或者www域名时，会主动检测DNS提供方是否将主域名和www域名都正确配置了（即使我们并不想使用重定向机制），像上图这样只添加了我们填写的Custom domain的这一条xinsong.xyz的解析记录，会提示我们：DNS valid for primary，www.xinsong.xyz就不能正确访问我们的站点，只能通过xinsong.xyz去访问。而如果这里的Custom domain是www.xinsong.xyz，并且也只添加了www的解析记录，那么这里也会提示：DNS valid for primary，并且报错：xinsong.xyz配置错误，也只能通过www.xinsong.xyz访问站点。如果不想看到Page报错和提示或者想使用双重定向机制，那么按照上面的方案一做就能正确配置不会报错了。\n因此提示 DNS valid for primary 是Github Page主动检查是否满足重定向机制的结果，一旦提示我们DNS valid for primary，说明未能创建双重定向，只有使用当前的Custom domain才能访问我们的站点。\n登录GitHub，进入之前创建的仓库，点击setting，设置Custom domain，输入你的域名。 这样就通过我们的个性化域名来访问我们自己的网站了。\n但是这样做每次推送到远端时这个Custom domain都会被覆盖，需要重新输入，因此还需要做如下操作：\n进入Blog/blog/source目录下，创建一个记事本文件，输入GitHub Page页面的Custom domain。这里建议是带www的域名。\n保存即可，命名为CNAME，注意保存类型选择所有文件而不是文本文件。\n这样我们每次推送到远端时就可以保证我们始终都能使用此域名进行访问。\n然后再进入blog文件中打卡powershell，依次执行：\n1 2 3 4 5 hexo clean hexo g hexo d 这时候无论怎么折腾，我们在浏览器中输入我们的域名，就可以访问我们的网站了。\n最终 GitHub Page推荐我们在配置一个主域名的同时配置一个 www 子域名。\n如果您通过 DNS 提供商正确配置一个顶级域名（例如 example.com ）和一个匹配的 www 子域名（例如 www.example.com ），GitHub 服务器会自动地创建双重定向。\n正确配置这两个域名后：\n如果你的 CNAME 文件为 example.com，那么 www.example.com 会定向到 example.com。 如果你的 CNAME 文件为 www.example.com，那么 example.com 会定向到 www.example.com。 警告：不要在你的 DNS 提供商上为你的自定义主域名创建一个 CNAME 记录！这样做可能会导致与其他服务，如电子邮件等，在该域的问题。\n所以根据GitHub Page的官方说明，总结下：\n使用子域名时（非www域），建议在DNS提供商上为该子域名创建一个 CNAME 记录，那么只能通过此子域去访问站点 单独使用主域名时（不配置www域），建议在DNS提供商上为该主域名创建一个 A 记录（CNAME可行，但不建议，可能发生电子邮件及其他服务的冲突问题），那么只能通过此主域访问站点 使用www/主域名时，建议在DNS提供商上为该主域名创建一个 A 记录，在DNS提供商上为该www域名创建一个 CNAME 记录即可自动创建双重定向（定向到我们CNAME文件中的地址，无论CNAME文件为 www.example.com 还是 example.com ），使用www域和主域均可访问站点 单独使用www域时，建议在DNS提供商上为该子域名创建一个 CNAME 记录，那么只能通过此www域去访问站点 自动重定向仅适用于www子域和其主域名之间，不适用于任何其他子域。\n你可以使用除了 www 以外的一个自定义子域名和一个自定义顶端域名来通过域名重定向（有时候也叫“域名转发”）。但是，请注意，这只能用于用户和组织的 Pages，而不是项目的 Pages。\n参考文章：\n在你的 DNS 提供者上配置 A 记录的技巧 - GitHub Pages 指南 - UDN开源文档 管理 GitHub Pages 站点的自定义域 - GitHub Docs ","date":"2022-12-05T16:46:59Z","permalink":"https://stack.xinsong.xyz/p/%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"搭建hexo个人博客"},{"content":"内联函数 C++中函数的使用我们已经比较清楚了，与C语言中函数的使用大多相同，主要是增加了重载的特性，对C语言的函数的一些缺陷做了一些补充。\n那么对于一些比较简单却又经常使用的功能，我们在C语言中常常使用宏来替换，宏呢与函数相比没有栈帧的开辟，类型的检查，没有传参，仅仅是做一个替换，非常适合功能简单却使用频繁的应用场景，但是宏正因为如此，也就具有了不安全、无法调试的缺陷，那么C++中如何处理这样地缺陷呢？\n内联函数应运而生它既继承了宏的优点也继承了函数的优点，即既没有开辟栈帧的开销，又可以去调试，并且有类型的检查。\n内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生 处理宏的一些问题。\n概念 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。\n函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。\n我们得明白，函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。\n如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视，要尽可能处理函数调用机制所用时间占比大的这种情况。\n为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。\n先来看看普通函数的调用过程：\n调用函数时是使用call指令，去调用某地址上的函数。（注意：普通函数都是有地址的，可以用以区分内联函数）\n如果在上述函数的前面加上inline关键字将其改为内联函数，在编译期间编译器会用函数体替换函数的调用。\n不过我们通常在Debug模式下默认函数不会被当做内联，即使你加上了inline，都会被编译器忽略，只有在release模式下，inline才有可能会被采纳，至于为什么是有可能，编译器只会把你的inline关键字当做一个建议，至于编译器是否按照你所要求的去做，这就不一定了，因为这仅仅是一个建议，编译器会结合具体情况比如函数体指令的多少来判断到底是否当做内联函数。\n所以我们如何去观察一个函数是否被当做内联函数呢？\n在release模式下\n查看编译生成的汇编代码中是否存在call Add\n监视器窗口查看Add函数是否有地址；\n在debug模式下需要对编译器进行设置，否则不会展开，因为在debug模式下，编译器默认不会对代码进行优化，内联函数其实算一种优化方式。\n在项目—\u0026gt;属性中找到 C/C++选项—\u0026gt;常规 ​\t将调试信息格式改为程序数据库(/Zi)\n在C/C++选项中找到优化\n将内联函数扩展选择—\u0026gt;只适用于__inline(Ob1)\n​\t重新生成可执行文件即可 完成后，我们便可以在debug模式下查看到内联函数的展开\n这里并没有call Add函数，而是函数体的展开（当然不仅仅是简单的展开，还会涉及一些其他指令，不做深入讨论）。\n特性 inline是一种空间换时间的做法 ，节省了开辟栈帧的时间开销； ​\t与调用普通函数相比不需要去开辟栈帧空间，节省了时间，相当于inline函数体所有指令都在当前栈内被执行；\ninline对于编译器仅仅是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等，编译器优化会自动忽略内联。 ​\t不仅是以上两种情况，函数体内的指令一旦较多，编译器就会自动忽略，如下：\n​\t函数体指令较复杂：\n​\t​\t函数体指令较简单：\ninline函数不建议声明和定义分离，分离会导致链接错误。因为inlinn函数被展开，也就不会有函数地址，自然不用提去链接了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //func.h文件 #pragma once #include\u0026lt;iostream\u0026gt; using namespace std; inline void f(int i); //func.cpp文件 #include\u0026#34;test.h\u0026#34; void f(int i) { cout \u0026lt;\u0026lt; \u0026#34;func\u0026#34; \u0026lt;\u0026lt; endl; } //main.cpp文件 #include\u0026#34;test.h\u0026#34; int main() { f(1); return 0; } 报错：error LNK2019: 无法解析的外部符号 \u0026ldquo;void __cdecl f(int)\u0026rdquo; (?f@@YAXH@Z)，函数 main 中引用了该符号。\n如果想要一个函数成为内联，但是类的定义和类实例化的地方在不同的源文件（声明定义分离），那么最好是将此函数定义在类中。\n对于内联函数，其工作原理是：\n对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。\n各个文件是分离编译的，在func.c中由于声明了f函数是内联的，并且函数体也很简短，因此编译器遵循了我们的建议，使其成为一个内联函数，由于没有函数地址，自然无法被除本源文件以外的地方调用；也可以说内联函数在符号表不会有合并这一步操作，仅仅存在于本源文件中。\n内联函数的缺点 难道内联函数就没有缺点吗，当然有！不然还要函数做什么？内联函数随着一次次的调用展开，会造成代码膨胀的问题，通俗讲就是生成的可执行文件会变大，这是我们不愿意看到的（有谁愿意看着自己的电脑硬盘被榨干呢？）\n可以大致从几个方面看：\n编译后的程序会存在多份相同的函数指令拷贝，这些函数拷贝编译后都是二进制的指令，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。 可执行程序在运行前要先载入内存，程序的执行就是一步步去内存取指令然后交给CPU执行的过程，可以试想可执行文件大，那么其指令也就越多，载入内存后消耗的空间也越大。 ​\t很好理解，普通的函数都有一个地址，每当我们需要使用这个函数时，直接通过函数名访问地址，然后就是建立栈帧的过程，在新栈帧中执行相应函数指令。\n​\t内联函数没有它的地址，我们需要调用这个函数时，只能临时拷贝一份，再执行相应指令。\n​\t举一个例子就是，普通函数就是一个坚信好 “记性不如烂笔头的乖学生”，老师讲一个重要的、多次使用的知识点时，他就记在笔记本上，需要了就拿出来看看就会了。内联函数也是一个爱记笔记的学生，不过它丢三落四的，刚记下笔记笔记本就丢了，每次需要时，就只能又去问老师再记下来，慢慢的他写过的笔记本就很多了，不过他自己还浑然不知。\n​\t他们两个同学的笔记本都是一个作用，就是记录下这个知识，但是随着使用次数的增加，这位有收拾的同学只需要一个笔记本就能终生受用，而这位丢三落四的同学则会随着记了又丢，丢了又记的过程产生很多个笔记本，内联函数也是同样的道理。\n那么它们的过程实际区别如下：\n​\t在程序载入过程中，两个函数体内容相同的普通函数和内联函数，普通函数的函数指令只向内存中载入了一次，之后每次调用此函数都只需要一条指令，直接访问其函数地址并取指令。\n​\t内联函数不会载入内存，没有函数地址。在编译后这些调用内联函数的语句都会被展开为内联函数的指令（做了一些特殊处理，并不是完全复制的函数体指令），由于编译后内联函数展开部分就只是一条条的指令，这些指令都会被载入内存，可以看到这里调用了多少次，内联就展开了多少次，展开的指令都会被载入内存，可以等效于调用了几次就将内联函数的指令载入了几次到内存。\n那么也就得出差异，普通函数只需要载入内存一次，而内敛函数是调用了几次就会载入内存几次。\n如果内联函数调用次数很多，调用结束后由于调用所产生的内存消耗并不会被释放（普通函数调用结束后栈帧会销毁） ​\t如图：\n总体来说，如果除去开辟栈帧的花销，内联函数和普通函数的所执行的指令数、时间几乎是相同的，重点在于如何把控执行一个函数时，它开辟的栈帧的消耗占整个函数调用的比重，如何把控这个比重，决定了我们是否建议一个函数为内联。\n我们来写个程序验证一下，并从指令的角度来看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 inline void func() { cout \u0026lt;\u0026lt; \u0026#34;func\u0026#34; \u0026lt;\u0026lt; endl; } int main() {\tfunc(); func(); func(); func(); return 0; } 来看看内联函数的汇编指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func(); 00007FF6AA4D1522 lea rdx,[string \u0026#34;func\u0026#34; (07FF6AA4DAE64h)] 00007FF6AA4D1529 mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1530 call std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1046h) 00007FF6AA4D1535 lea rdx,[std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1014h)] 00007FF6AA4D153C mov rcx,rax 00007FF6AA4D153F call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF6AA4E01B0h)] func(); 00007FF6AA4D1545 lea rdx,[string \u0026#34;func\u0026#34; (07FF6AA4DAE64h)] 00007FF6AA4D154C mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1553 call std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1046h) 00007FF6AA4D1558 lea rdx,[std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1014h)] 00007FF6AA4D155F mov rcx,rax 00007FF6AA4D1562 call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF6AA4E01B0h)] func(); 00007FF6AA4D1568 lea rdx,[string \u0026#34;func\u0026#34; (07FF6AA4DAE64h)] 00007FF6AA4D156F mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1576 call std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1046h) 00007FF6AA4D157B lea rdx,[std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1014h)] 00007FF6AA4D1582 mov rcx,rax 00007FF6AA4D1585 call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF6AA4E01B0h)] func(); 00007FF6AA4D158B lea rdx,[string \u0026#34;func\u0026#34; (07FF6AA4DAE64h)] 00007FF6AA4D1592 mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1599 call std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1046h) 00007FF6AA4D159E lea rdx,[std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt; (07FF6AA4D1014h)] 00007FF6AA4D15A5 mov rcx,rax 00007FF6AA4D15A8 call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF6AA4E01B0h)] 接着我们取消内联再来看看：\n1 2 3 4 5 6 7 8 func(); 00007FF679261572 call func (07FF679261285h) func(); 00007FF679261577 call func (07FF679261285h) func(); 00007FF67926157C call func (07FF679261285h) func(); 00007FF679261581 call func (07FF679261285h) 差别还是蛮大的，这些指令都会在运行时载入内存，造成代码膨胀。\n一些其他不足 通常，编译器比程序设计者更清楚对于一个特定的函数是否合适进行内联扩展；一些情况下，对于程序员指定的某些内联函数，编译器可能更倾向于不使用内联甚至根本无法完成内联。 对于一些开发中的函数，它们可能从原来的不适合内联扩展变得适合或者倒过来。尽管内联函数或者非内联函数的转换易于宏的转换，但增加的维护开支还是使得它的优点显得更不突出了。 对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。 判断是否设置为内联：一般只将那些短小的、频繁调用的函数声明为内联函数。\n最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。\nauto关键字 auto为自动的意思，C语言中貌似也有提到过（自动变量什么的，记不清了几乎没使用过），那么在C++中auto有什么作用、应用于哪些场景呢？\nauto简介 在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它，大家可思考下为什么？\nC++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { auto a = 1; auto b = 2.0; auto c = 2.0f; auto d = \u0026#39;w\u0026#39;; cout \u0026lt;\u0026lt; typeid(a).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(b).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(c).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(d).name() \u0026lt;\u0026lt; endl; return 0; } //auto e;无法通过编译。 既然是编译期间自动推导类型，那么就说明一定得初始化咯。\n使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。\n详细使用规则 既然是占位符则说明auto可以是任何类型，而不一定是对其进行初始化数据的类型。\nauto和指针结合起来使用 ​\t用auto声明指针类型时，用auto和auto*没有任何区别，但是auto对于引用的声明必须加上\u0026amp;；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { int a = 10; auto p1 = \u0026amp;a;//auto在编译时会被替换为int* auto* p2 = \u0026amp;a;//auto在编译时会被替换为int int\u0026amp; ref = a; auto ref1 = ref;//ref是a的别名，因此推导出是int类型 ref1 = 12;//a并不会改变 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(a).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(ref).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(p1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(p2).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(ref1).name() \u0026lt;\u0026lt; endl; return 0; } 同一行定义多个变量 ​\t在同一行定义多个变量时，这些变量的类型必须相同，否则编译器会报错，因为编译器实际只对第一个类型进行推导，然后替换为auto，并用该类型定义其他变量。\n1 2 3 4 5 int main() { auto a = 1, b = 1.0; return 0; } 在声明符列表中，“auto”必须始终推导为同一类型\n这样看auto好像还挺万能的，那么auto能适用于所以场景吗？\nauto不能推导类型的场景 不能作为函数的形参 1 2 3 4 5 // 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a和b的实际类型进行推导 int Add(auto a, auto b) { return a + b; } error C3533: 参数不能为包含“auto”的类型\n函数在编译时是需要形参类型来确定修饰后函数名的，所以形参类型要先确定。\n这种显然是不可行的，如果可以直接使用auto推导，那么就没后面的模板什么事了。\n注：返回值是可以用auto的。\n不能用来直接声明数组 1 2 3 4 5 int main() { auto arr[] = { 1,2,3,4,5 }; return 0; } error C3318: “auto []”: 数组不能具有其中包含“auto”的元素类型\nerror C3535: 无法推导“auto []”的类型(依据“initializer list”)\n为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法 auto为了在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等 进行配合使用 基于范围的for循环 for循环是我们非常熟悉的，用法也比较单一，通常在知道循环次数的情况下使用，那么什么是范围for呢？\n范围for的语法 C++98中如果我们要遍历一个数组通常是下面这种方式：\n1 2 3 4 5 6 7 8 void TestFor() { int array[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u0026lt; sizeof(array) / sizeof(array[0]); ++i) array[i] *= 2; for (int* p = array; p \u0026lt; array + sizeof(array) / sizeof(array[0]); ++p) cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; } 对于一个范围已知的集合而言，由我们来说明循环的范围显然是多余的，有时候不注意还会出错。因此C++11中引入了基于范围的for循环。for循环后的括号由冒号“:”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。\n1 2 3 4 5 6 7 8 void TestFor() { int array[] = { 1, 2, 3, 4, 5 }; for (auto\u0026amp; e : array) e *= 2; for (auto e : array) cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 循环体内就和普通的循环一样了，我们可以使用break跳出循环，也可以使用continue结束本次循环，只不过是编译器帮助我们确定迭代的范围而已。\n范围for的使用条件 for循环迭代的范围是确定的 对于数组而言，迭代的范围就是从第一个元素到最后一个元素；\n对于类而言，应该提供begin以及end的方法，循环的范围就是从begin到end；\n也就是说我么给for的应该是一组数据集合，例如数组，链表等等…\n看看一下代码是否有问题：\n1 2 3 4 5 void TestFor(int array[]) { for (auto\u0026amp; e : array) cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } “begin”: 未找到匹配的重载函数\n显然是有问题的，数组名作为形参，其本质上是一个指针，指针是一组数据的集合吗？？显然不是。\n迭代的对象的迭代器要实现++和==的操作。(关于迭代器这个问题，以后会讲，现在大家了解一下就可以了) ​\t可以先简单说说迭代器，迭代器就是一个封装后的指针，通过这个封装后的指针我们可以通过地址找到数据的存储位置。为什么要封装呢？因为对于原生指针我们执行++操作，它是在相邻的位置移动，这样对于链表等数据结构是无法正确访问的，可如果我们对++操作符进行重载，就可以让它根据他的存储特性去移动指针了！\n新的指针空值nullptr C++11 从学习C语言之初，我们就说要养成一个好习惯——声明一个变量时给一个合适的初值，否则可能会出现不可预料的错误，比如未初始化的指针。如果当前指针没有明确的指向，那么可以给其赋值为空；\n1 2 3 4 5 6 int main() { int* p = NULL; int* p1 = 0; return 0; } 这两者其实是一样的，NULL其实是一个宏，即是0值；\n在传统C头文件里(stddef.h)中，可以看到如下代码：\n1 2 3 4 5 6 7 #ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void func(int) { cout \u0026lt;\u0026lt; \u0026#34;f(int)\u0026#34; \u0026lt;\u0026lt; endl; } void func(int*) { cout \u0026lt;\u0026lt; \u0026#34;f(int*)\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(0); func(NULL); func((int*)NULL); return 0; } 我们的本意是让func(NULL)去调用void func(int*)的，但却出现了问题，由于NULL被定义成0，而0默认被当做一个整型，因此与程序的初衷相悖。\n在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。\n因此在C++程序中我们更倾向使用nullptr而不是NULL，来看看nullptr是什么。\n1 2 3 4 5 6 7 8 int main() { int* p = NULL; int* p1 = 0; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; typeid(NULL).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; typeid(nullptr).name() \u0026lt;\u0026lt; endl; return 0; } 注意：\n在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。\n在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。\n为了提高代码的健壮性（适用于更多场景），在后续表示指针空值时建议最好使用nullptr。\n","date":"2022-12-05T16:25:27Z","permalink":"https://stack.xinsong.xyz/p/c-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/","title":"C++入门基础"},{"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post 1 $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server 1 $ hexo server More info: Server\nGenerate static files 1 $ hexo generate More info: Generating\nDeploy to remote sites 1 $ hexo deploy More info: Deployment\n","date":"0001-01-01T00:00:00Z","permalink":"https://stack.xinsong.xyz/p/hello-world/","title":"Hello World"}]